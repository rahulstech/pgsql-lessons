### DataType

**Basic Types:**
- INT / INTEGER / BIGINT / BIGINTEGER same as `INTEGER` in SQLite
- SERIAL / BIGSERIAL same as `INTEGER AUTOINCREMENT` in SQLite
- VARCHAR(N) / CHAR(N) / TEXT same as TEXT in SQLite
  - VARCHAR takes size as much as the length of the string
  - CHAR takes N size no matter what is the length string, it adds space to pad the string if the string length is less than N
- NUMERIC(X,Y) / DECIMAL(X,Y) same as REAL in SQLite
  - there is no difference between `NUMERIC` and `DECIMAL` in pgsql
  - X is total no of digits Y is digits after period. so digits before period is X-Y. 

  ```sql
  -- instead of NUMERIC(5,2) i can use DECIMAL(5,2) still the effect is same
  create table B (b numeric(5,2));
  
  -- successful queries
  insert into B values (123.45);
  insert into B values (123.4);
  insert into B values (123);
  
  -- fail queries
  insert into B values (1234.5); -- integer length is 4 and decimal length is 2 (50) so total length 6, exceeds the allowed length 5
  insert into B values (1234); -- here length of integer part is 4 and decimal part is 2 (00) so total length 6 exceeds the allowed length 5
  ```
  - i can also use NUMERIC it is same as NUMERIC(15). it will allow both 16 and 16.5 i.e. integer and non-integer

- BOOLEAN true, false, 't', 'f', 'yes', 'no', '1', '0'

- TIMESTAMP, TIMESTAMPTZ date time and timezone if TIMEZONETZ

- INTERVAL duration (e.g. interval '2 days', interval '3 hours').

**Note** Postgresql is data type restrictive. so it does not allow to insert data of different type other than datatype defined for the column but sqlite do allow. for example;

```sql
-- sqlite
create table A(a integer);

-- following query will execute without any error
insert into A values (15),("15"),("not-a-number");

-- pgsql
create table A (a numeric);

-- following query will execute successfully
insert into A values (15), ('15');

-- but following query will fail as trying to insert text data in number column
insert into A values ('not-a-number');
```

**Sequence Serial and Identity:**
  - serial starts from 1 and increments by 1.
  - serial is 4 bytes integer, there is bigserial too which is 8 bytes integer
  
    ```sql
    create table customers (id serial primary key, name text not null);

    insert into customers (name) values ('customer 1'), ('customer 2'), ('customer 3');

    select * from customers;
    ```

    - creates sequence that starts with 100 and increments by 2 i.e. 100, 102, 104...
    
      **NOTE1:** start and increment are always required
      
      **NOTE2:** serial is same as create sequence tablename_serial_seq; by default it starts from 1 and increments by 1
    
    ```sql
    create sequence orders_seq start 100 increment 2;
    ```

  - use orders_seq as primary key. here orders table will assign the next value from sequence if no id is provided otherwise provided id will be set.

    ```sql
    create table orders (id int default nextval('orders_seq') primary key, cust_id int not null references customers(id), amount numeric(12,2) not null default 0.0);

    insert into orders (cust_id, amount) values (1,150), (1, 140), (1, 160.5);

    select * from orders;
    -- output => (id, cust_id, amount) = (100, 1, 150.00), (102, 1, 140.00), (104, 1, 160.00)
    ```

    - the insert query will fail as cust_id=4 does not exist currently (foreign key constraint fail)
      
      **NOTE:** though it fails the sequence still increases
    
    ```sql
    insert into orders (cust_id, amount) values (4, 100);
    ```

  - setting id value manually has no restriction to follow the sequence rule. for example: the ids must be 106 and 108 but i added 109 and 111 still accepted

    ```sql
    insert into orders (id, cust_id, amount) values (109, 2, 100), (111, 2, 170);

    select * from orders;
    -- output => (id, cust_id, amount) = (109, 2, 100.00), (111, 2, 170.00)

    insert into orders (id, cust_id, amount) values (112, 3, 155);

    select * from orders;
    -- output => (id, cust_id, amount) = (112, 3, 155.00)

    insert into orders (cust_id, amount) values (3, 178), (3, 185);

    select * from orders;
    -- output => (id, cust_id, amount) = (108, 3, 178.00), (10, 3, 185.00)
    ```

  - here is the tricky part, the query fails on first run but succeeds in second run
    because first the sequence become 112 but 112 already exists to can not insert as primary key conflicts
    but second time the sequence becomes 114 which currently does not exist so insert is successful
  
    ```sql
    insert into orders (cust_id, amount) values (3, 250);

    select * from orders;
    -- output => (id, cust_id, amount) = (114, 3, 250.00)
    ```

  - generated by default as identity

    ```sql
    create table products (id int generated by default as identity primary key, name text not null);

    insert into products (name) values ('product 1');

    select * from products;
    -- output: (id,name) = (1, 'product 1')
    ```

  - since generated by default as identity is used for id, therefore it allows manual setting of id if no id is set then it set next value from its sequence

    ```sql
    insert into products (id, name) values (3, 'product 2');

    select * from products;
    -- output: (id,name) = (3, 'product 2')

    -- sets the next value from identity internal sequence
    insert into products (name) values ('product 3');

    select * from products;
    -- output: (id,name) = (2, 'product 3')
    ```

  - the next auto id must be 3 but 3 already exists. so just like sequence it will fail in first run but succeed in second run with id set to 4

    ```sql
    insert into products (name) values ('product 4');

    select * from products;
    -- output: (id,name) = (4, 'product 4')
    ```

  - generated always as identity
  
    ```sql
    create table reviews (id int generated always as identity primary key, prod_id int not null references products(id), message text not null);

    insert into reviews (prod_id, message) values (1, 'this product is good');

    select * from reviews;
    -- output: (id,prod_id,message) = (1,1,'this product is good')
    ```

  - this will fail as trying to manually insert the id
    
    ```sql
    insert into reviews (id, prod_id, message) values (2, 2, 'this product is not as good as expected');
    ```

  - custom sequence for identity
  - a sequence as generated, but this is not required, explained below

    ```sql
    create sequence ratings_seq start 5 increment 5;
    ```

    ```sql
    create table ratings (
        -- id int generated always as nextval('ratings_seq'), <- this is not allowed and create table will fail
        -- instead i can do the same in following way. identity by default creates start 1 increment 1 sequence
        id int generated always as identity (start 5 increment 5),
        rating int not null check ( rating > 0 and rating < 6 )
                        );

    insert into ratings (rating) values (5);

    select * from ratings;
    -- output: (id, rating) = (5,5)

    insert into ratings (rating) values (3);

    select * from ratings;
    -- output: (id,rating) = (10,3)
    ```

**Type casting:**
```sql
select 94258763::varchar;
select '15'::int;
select '15.24'::numeric; -- same result for select '15.24'::decimal
select '15.24'::int; -- it is an error;
select '15.24'::decimal::int; --- exeute without problem
select 15.3::int;

select '2024-05-15'::date;
select '2024-05-15'::time; -- this is an error, time does not exists in the string
select '2024-05-15 15:36'::time; -- returns 15:36:00
select '2024-05-15 16:21'::timestamptz; -- date time and timezone, timezone set to current session timezone
```

**json and jsonb:**
  usage difference between `json` and `jsonb` (json binary) is
  - use json when storing and getting the whole value is the only intension
  - use jsonb when partial update, query based on json attribute, indexing etc. are required

  ```sql
  drop table if exists A;

  create table A (id serial, data jsonb);

  insert into A (data) values
                  ('{"language": "english", "age": 30}'), -- i have inserted the josnb value as text
                  ('{"language": "english", "age": 28}'),
                  ('{"language": "spanish", "age": 25}'),
                  ('{"language": "french", "age": 28}'),
                  ('{"language": "russian", "age": 27}'),
                  ('{"language": "french", "age": 29}'),
                  ('{"language": "english", "age": 22}'),
                  ('{"language": "english", "age": 27}'),
                  ('{"language": "spanish", "age": 32}'),
                  ('{"language": "french", "age": 24}'),
                  ('{"language": "russian", "age": 29}'),
                  ('{"language": "french", "age": 24}');
  ```

  - Accessing jsonb attributes
    - -> return type is jsonb
    - ->> return type is text
    - #> return type is jsonb
    - #>> return type is text
    - ->, ->> used for top level attribute
    - #>, #>> used for nested attribute, ex: {"attr1": {"child1": "value1"}} then to get the value of attr.child1 use #> or #>>

  - filter by jsonb attribute
  
    **NOTE:** for json/jsonb attribute single quote ('') is used, but for alias name double quote ("") is used

    ```sql
    select
      data->>'language' "language_as_text", -- returns as english (without double quote)
      data->'language' "language_as_jsonb"  -- returns as "english" (inside double quote)
    from A where
              (data->>'age')::numeric >= 28; -- since data->>'age' is text type, cast it to number type (numeric, decimal, int) for arithmetic comparison
    ```

  - returns the value of `attr1.child1` i.e. _value1_. return type is _jsonb_
    ```sql
    insert into A (data) values ('{"attr1": {"child1": "value1", "child2": "value2"}}');

    select data#>'{attr1,child1}' "attr1-child1" from A;
    ```

  - returns value of attr1.child2 i.e. value2. return type is text.

    ```sql
    select data#>>'{attr1,child2}' "attr1-child2" from A;
    ```

  - the following query shows the return types
  
    ```sql
    select pg_typeof(data#>'{attr1,child1}') "typeof_attr1-child1", -- returns jsonb
          pg_typeof(data#>>'{attr1,child2}') "typeof_attr1-child2" -- returns text
    from A;
    ```

  - print each key-value pair of json in data column as separate row. for example: {"age": 30, "language": "english"} become (age,30), (language, english) in tow rows
  
    **NOTE:** each record item is text type
    
    ```sql
    select jsonb_each_text(data) "record", -- returns in record type, ex: (key, value)
          pg_typeof(jsonb_each_text(data)) "type" -- returns record
    from A;
    ```

  - update single attribute in jsonb

    **NOTE:** jsonb_set updates only single attribute at a time
    
    ```sql
    update A set
                data = jsonb_set(data, '{age}', '23')
            where id = 8;

    select * from A where id = 8;
    ```

  - update a multiple attribute in jsonb,
    
    **NOTE:** following will fail because here i am trying to update the data twice
    
    ```sql
    update A set
                data = jsonb_set(data, '{age}', '23'),
                data = jsonb_set(data,'{language}', '"hindi"')
            where id = 8;
    ```

  - solution 1: updating multiple attributes. i will use it only when the jsonb has multiple attributes but will change 2 or 3 attributes only
    
    ```sql
    update A set
                data = jsonb_set(
                      jsonb_set(data, '{age}', '24'), -- it returns updated age then i apply language update
                      '{language}', '"hindi"'
                      )
            where id = 8;

    select * from A where id = 8;
    ```

  - solution 2: updating multiple attributes. i will use it when there are limited attributes, i need to update 2 or more attribute together and everytime i know the unchanged attribute values too
    
    ```sql
    update A set
                data = '{"age": 25, "language": "bengali"}'::jsonb -- NOTE: cast it to jsonb for safety
            where id = 8;

    select * from A where id = 8;
    ```

  - update a single nested attribute in jsonb,
    
    ```sql
    update A set
                data = jsonb_set(data, '{attr1,child1}', '"updated-child1"'::jsonb)
            where id = 13;

    select * from A where id = 13;
    ```

  - update a jsonb attribute or add if not exists
    
    **NOTE:** the optional fourth parameter adds the attribute if not exists, by default it is true
  
    ```sql
    update A set
                data = jsonb_set(data,'{experience}','5', true) 
            where id = 8;

    select * from A where id = 8;
    ```