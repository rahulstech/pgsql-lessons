### DataType

**Basic Types:**
- INT / INTEGER / BIGINT / BIGINTEGER same as `INTEGER` in SQLite
- SERIAL / BIGSERIAL same as `INTEGER AUTOINCREMENT` in SQLite
- VARCHAR(N) / CHAR(N) / TEXT same as TEXT in SQLite
  - VARCHAR takes size as much as the length of the string
  - CHAR takes N size no matter what is the length string, it adds space to pad the string if the string length is less than N
- NUMERIC(X,Y) / DECIMAL(X,Y) same as REAL in SQLite
  - there is no difference between `NUMERIC` and `DECIMAL` in pgsql
  - X is total no of digits Y is digits after period. so digits before period is X-Y. 

  ```postgresql
  -- instead of NUMERIC(5,2) i can use DECIMAL(5,2) still the effect is same
  create table B (b numeric(5,2));
  
  -- successful queries
  insert into B values (123.45);
  insert into B values (123.4);
  insert into B values (123);
  
  -- fail queries
  insert into B values (1234.5); -- integer length is 4 and decimal length is 2 (50) so total length 6, exceeds the allowed length 5
  insert into B values (1234); -- here length of integer part is 4 and decimal part is 2 (00) so total length 6 exceeds the allowed length 5
  ```
  - i can also use NUMERIC it is same as NUMERIC(15). it will allow both 16 and 16.5 i.e. integer and non-integer

- BOOLEAN true, false, 't', 'f', 'yes', 'no', '1', '0'

- TIMESTAMP, TIMESTAMPTZ date time and timezone if TIMEZONETZ

- INTERVAL duration (e.g. interval '2 days', interval '3 hours').

**Note** Postgresql is data type restrictive. so it does not allow to insert data of different type other than datatype defined for the column but sqlite do allow. for example;

```postgresql
-- sqlite
create table A(a integer);

-- following query will execute without any error
insert into A values (15),("15"),("not-a-number");

-- pgsql
create table A (a numeric);

-- following query will execute successfully
insert into A values (15), ('15');

-- but following query will fail as trying to insert text data in number column
insert into A values ('not-a-number');
```

**Sequence Serial and Identity:**
  - serial starts from 1 and increments by 1.
  - serial is 4 bytes integer, there is bigserial too which is 8 bytes integer
  
    ```postgresql
    create table customers (id serial primary key, name text not null);

    insert into customers (name) values ('customer 1'), ('customer 2'), ('customer 3');

    select * from customers;
    ```

    - creates sequence that starts with 100 and increments by 2 i.e. 100, 102, 104...
    
      **NOTE1:** start and increment are always required
      
      **NOTE2:** serial is same as create sequence tablename_serial_seq; by default it starts from 1 and increments by 1
    
    ```postgresql
    create sequence orders_seq start 100 increment 2;
    ```

  - use orders_seq as primary key. here orders table will assign the next value from sequence if no id is provided otherwise provided id will be set.

    ```postgresql
    create table orders (id int default nextval('orders_seq') primary key, cust_id int not null references customers(id), amount numeric(12,2) not null default 0.0);

    insert into orders (cust_id, amount) values (1,150), (1, 140), (1, 160.5);

    select * from orders;
    -- output => (id, cust_id, amount) = (100, 1, 150.00), (102, 1, 140.00), (104, 1, 160.00)
    ```

    - the insert query will fail as cust_id=4 does not exist currently (foreign key constraint fail)
      
      **NOTE:** though it fails the sequence still increases
    
    ```postgresql
    insert into orders (cust_id, amount) values (4, 100);
    ```

  - setting id value manually has no restriction to follow the sequence rule. for example: the ids must be 106 and 108 but i added 109 and 111 still accepted

    ```postgresql
    insert into orders (id, cust_id, amount) values (109, 2, 100), (111, 2, 170);

    select * from orders;
    -- output => (id, cust_id, amount) = (109, 2, 100.00), (111, 2, 170.00)

    insert into orders (id, cust_id, amount) values (112, 3, 155);

    select * from orders;
    -- output => (id, cust_id, amount) = (112, 3, 155.00)

    insert into orders (cust_id, amount) values (3, 178), (3, 185);

    select * from orders;
    -- output => (id, cust_id, amount) = (108, 3, 178.00), (10, 3, 185.00)
    ```

  - here is the tricky part, the query fails on first run but succeeds in second run
    because first the sequence become 112 but 112 already exists to can not insert as primary key conflicts
    but second time the sequence becomes 114 which currently does not exist so insert is successful
  
    ```postgresql
    insert into orders (cust_id, amount) values (3, 250);

    select * from orders;
    -- output => (id, cust_id, amount) = (114, 3, 250.00)
    ```

  - generated by default as identity

    ```postgresql
    create table products (id int generated by default as identity primary key, name text not null);

    insert into products (name) values ('product 1');

    select * from products;
    -- output: (id,name) = (1, 'product 1')
    ```

  - since generated by default as identity is used for id, therefore it allows manual setting of id if no id is set then it set next value from its sequence

    ```postgresql
    insert into products (id, name) values (3, 'product 2');

    select * from products;
    -- output: (id,name) = (3, 'product 2')

    -- sets the next value from identity internal sequence
    insert into products (name) values ('product 3');

    select * from products;
    -- output: (id,name) = (2, 'product 3')
    ```

  - the next auto id must be 3 but 3 already exists. so just like sequence it will fail in first run but succeed in second run with id set to 4

    ```postgresql
    insert into products (name) values ('product 4');

    select * from products;
    -- output: (id,name) = (4, 'product 4')
    ```

  - generated always as identity
  
    ```postgresql
    create table reviews (id int generated always as identity primary key, prod_id int not null references products(id), message text not null);

    insert into reviews (prod_id, message) values (1, 'this product is good');

    select * from reviews;
    -- output: (id,prod_id,message) = (1,1,'this product is good')
    ```

  - this will fail as trying to manually insert the id
    
    ```postgresql
    insert into reviews (id, prod_id, message) values (2, 2, 'this product is not as good as expected');
    ```

  - custom sequence for identity
  - a sequence as generated, but this is not required, explained below

    ```postgresql
    create sequence ratings_seq start 5 increment 5;
    ```

    ```postgresql
    create table ratings (
        -- id int generated always as nextval('ratings_seq'), <- this is not allowed and create table will fail
        -- instead i can do the same in following way. identity by default creates start 1 increment 1 sequence
        id int generated always as identity (start 5 increment 5),
        rating int not null check ( rating > 0 and rating < 6 )
                        );

    insert into ratings (rating) values (5);

    select * from ratings;
    -- output: (id, rating) = (5,5)

    insert into ratings (rating) values (3);

    select * from ratings;
    -- output: (id,rating) = (10,3)
    ```

**Type casting:**

```postgresql
select 94258763::varchar;
select '15'::int;
select '15.24'::numeric; -- same result for select '15.24'::decimal
select '15.24'::int; -- it is an error;
select '15.24'::decimal::int; --- exeute without problem
select 15.3::int;

select '2024-05-15'::date;
select '2024-05-15'::time; -- this is an error, time does not exists in the string
select '2024-05-15 15:36'::time; -- returns 15:36:00
select '2024-05-15 16:21'::timestamptz; -- date time and timezone, timezone set to current session timezone
```